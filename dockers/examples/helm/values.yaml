timezone: null
origin: null

## @section Global parameters
## @param replicaCount represents the number of pods that will be created for the application
## Set 'replicaCount' to a specific integer value to define the required number of replicas
## Higher values increase the system's ability to handle traffic and provide redundancy
## *NOTE*: Increasing 'replicaCount' may impact system resource usage
replicaCount: 1
## @param nameOverride represents the name that should override the default naming of the application
## Leave 'nameOverride' as an empty string to keep the default naming
## Assign a specific string value to 'nameOverride' to define the required name for the application
nameOverride: ""
## @param fullnameOverride represents the full name that should override the default full naming of the application
## Leave 'fullnameOverride' as an empty string to keep the default full naming
## Assign a specific string value to 'fullnameOverride' to define the required full name for the application
fullnameOverride: ""

## @param nodeSelector is a dictionary that adds scheduling constraints to the pods of the application. These constraints can specify the properties of the desired host of the pods.
## The format for nodeSelector should be: 'LABEL: value'
## Any number of labels can be added to this object.
## To add a label, simply include a new line in the 'nodeSelector: {}' block,
## with the key-value pair representing the label and its corresponding value. The application pods will be scheduled on nodes that match these labels.

nodeSelector: {}

## @param tolerations A list of tolerations that can be applied to Pods of the application. Each entry should represent a separate toleration.
## Tolerations are applied to pods in the case where you want the pods to tolerate the effects of taints, which mark a node as 'unschedulable'.
## If a Pod has a Toleration that matches a Node's Taint, the Pod can be scheduled to the tainted Node.
## Each toleration is represented as an object with properties including 'key', 'operator', 'value', 'effect', and 'tolerationSeconds'.
## The 'key' and 'value' properties define the taint that the toleration matches.
## The 'operator' defines the match relationship between the taint and toleration (e.g., 'Equal' or 'Exists').
## The 'effect' property defines the taint effect that is tolerated (e.g., 'NoSchedule', 'PreferNoSchedule', or 'NoExecute').
## The 'tolerationSeconds' property optionally defines how long a pod with such toleration will stay bound to the node after it has been marked for deletion.

tolerations: []

## @param affinity The `affinity` parameter is an object that sets the scheduling constraints on the pods of the application by setting affinity rules. Affinity rules
## allow you to restrict the nodes on which the application pods are scheduled based on several factors such as labels present on the nodes,
## conditions based on the statuses of other pods etc. This can help you ensure that the application pods are scheduled on the nodes that satisfy
## specific conditions. Affinity supports  'nodeAffinity', 'podAffinity', and 'podAntiAffinity' properties.
##
## The `affinity` object should have a valid formatting that follows the Kubernetes affinity rules. If it is left empty (affinity: {}), no affinity
## rules are applied, meaning that the scheduler is free to place the pods on any available node that meets the requirements.
##
## For example, a typical usage of the affinity parameter in production environments might involve spreading the pods of a specific application across
## different nodes to ensure high availability by setting 'podAntiAffinity' rules. Or you might want to confine the pods to a set of nodes with specific
## labels by adding 'nodeAffinity' rules.
affinity: {}


## @param envVars is a dictionary object that can be used to set Environment Variables in the application.
## The format for envVars should be: 'ENV_VARIABLE_NAME: value'
## Any number of environment variables can be added to this object.
## To add an environment variable, simply include a new line in the 'envVars: {}' block,
## with the key-value pair representing the variable name and its corresponding value.
envVars: {}

## @param podAnnotations provides additional metadata for pods in the form of annotations.
## Annotations are key-value pairs that can be used to provide non-identifying data for pods.
## They can store large amounts of data, such as JSON blobs, and unlike labels, they do not impact the systemâ€™s internal behavior.
## In this case, 'podAnnotations' is an empty object, indicating no annotations have been added to the pods.
## To add an annotation, simply insert a new line within the 'podAnnotations: {}' block with the format 'ANNOTATION_NAME: value'
## This is useful for tools and libraries that operate at the Kubernetes level.
podAnnotations: {}

## @section OCI parameters
## These parameters will change the way of how OCI is fetched
image:
  ## @param image.repository denotes the name of the image repository, in this case 'nginx'
  repository: ghcr.io/teableio/teable
  ## @param image.pullPolicy a Kubernetes directive which describes how to fetch the Docker image
  pullPolicy: IfNotPresent
  #  credentials:
  ## @extra image.credentials.name: A string representing the name of these credentials, which can be any string.
  #    name: foo
  ## @extra image.credentials.registry: The string value representing the domain of the image registry. In this example, "gitlab.com"
  #    registry: "gitlab.com"
  ## @extra image.credentials.username: The string value representing the username for authentication at the mentioned registry
  #    username: "user"
  ## @extra image.credentials.password: The string value representing the password for the mentioned username at the registry
  #    password: "pass"
  ## @param image.tag used to reference a specific image snapshot in the image repository.
  tag: ""


## @section Service parameters
## @descriptionStart
## This section defines parameters for the service which exposes the application to the network.
## @descriptionEnd
service:
  ## @param service.type The type of the service. It can be one of the following: ClusterIP, NodePort, LoadBalancer, or ExternalName.
  type: ClusterIP
  ## @param service.port The port on which the service will listen. Here, it is set to 80.
  port: 80
  ## @param service.targetPort The port of the target Pods where the HTTP service is running. Here, it's also set to 80.
  targetPort: 3000
  ## @param service.annotations This is the place to specify additional annotations for the service. Here, it's an empty object,
  ## indicating there are no custom annotations specified for the service.
  annotations: {}


## @section Probe parameters
## @descriptionStart
## This section defines liveness, readiness, and startup probes for Kubernetes.
## Probes allow Kubernetes to check for certain conditions and respond accordingly.
## @descriptionEnd

probes:
  ## @extra probes.liveness The kubelet uses liveness probes to know when to restart a container.
  liveness:
    ## @skip probes.liveness.path
    path: /
  ## @param probes.readiness The kubelet uses readiness probes to know when a container is ready to start accepting traffic.
  ## If the readiness probe fails, the endpoints controller removes the Pod's IP address from the endpoints of all Services that match the Pod.
  readiness: null
  ## @extra probes.startup The kubelet uses startup probes to know when a container application has started.
  ## If such a probe is configured, it disables liveness and readiness checks until it succeeds, making sure those probes don't interfere with the application startup.
  startup:
    ## @skip probes.startup.path
    path: /

## @section Ingress parameters
## @descriptionStart
## 'ingress' controls the properties of the Ingress resource to be created for the application.
## @descriptionEnd
## @param ingress.className Optional string used to tie Ingress resources with specific IngressClass objects.
## @param ingress.enabled Flag to enable the creation of the Ingress. Default is 'false'.
## @param ingress.annotations Further annotations to add to the Ingress resource object.
## @param ingress.hosts A list of hosts and their respective paths to be included in the Ingress object.
## @param ingress.tls.additional Additional configuration for ingresses that will enable SSL certificates for multiple hosts.
ingress:
  className: null
  enabled: false
  annotations: {}
  hosts: []
  #    - host: chart-example.local
  #      paths: []
  tls:
    additional: []
#      - secretName: chart-example-tls
#        hosts:
#          - chart-example.local

## @section Resource parameters
## @descriptionStart
## This configuration block defines the resources requests and limits for the pods in the deployment.
## Kubernetes uses requests for scheduling pods on its nodes, and to ensure fair resource sharing between pods.
## Limits come into play to guarantee a maximum amount of a resource that a pod can consume, preventing it affecting other pods adversely.
## This block has two main components: `limits` and `requests`, each for CPU and memory.
## @descriptionEnd

#resources:
#   limits:
## @extra resources.limits.cpu: The maximum amount of CPU a pod can use. If the CPU use exceeds this limit,
## the system may throttle the processes in the pod. '100m' implies 0.1 of a CPU core.
#     cpu: 100m
## @extra resources.limits.memory: The maximum amount of memory a pod can use. If a pod exceeds this limit,
## it might be terminated. '128Mi' implies 128 Mebibytes of memory.
#     memory: 128Mi
#   requests:
## @extra resources.requests.cpu: The amount of CPU a pod requests upon scheduling. Kubernetes guarantees to allocate this amount of CPU. '100m' implies 0.1 of a CPU core.
#     cpu: 100m
## @extra resources.requests.memory: The amount of memory a pod requests upon scheduling. Kubernetes guarantees to allocate this amount of memory. '128Mi' implies 128 Mebibytes of memory.
#     memory: 128Mi

## @section Autoscaling
## @descriptionStart
## Parameters for enabling and controlling autoscaling of pods based on defined conditions.
## note: these settings only apply when autoscaling is enabled.
## @descriptionEnd
## @param autoscaling.enabled Set this to true to enable autoscaling, and to false to disable it.
## @param autoscaling.minReplicas Defines the minimum number of pods to deploy.
## @param autoscaling.maxReplicas Defines the maximum number of pods which can be deployed.
## @param autoscaling.targetCPUUtilizationPercentage Defines the percentage of CPU utilization that the system should attempt to maintain. When this value is exceeded, the system will scale up.
## @extra autoscaling.targetMemoryUtilizationPercentage Defines the percentage of memory utilization that the system should attempt to maintain. When this value is exceeded, the system will scale up.
##
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
#  targetMemoryUtilizationPercentage: 80

## @section Service Account
## @descriptionStart
## This configuration block is used for controlling parameters linked to service account preferences.
## The service account is used by the application in the code to interact with the Kubernetes API.
## @descriptionEnd
## @param serviceAccount.create A boolean field indicating whether a new service account should be created for your deployment (true) or use an existing one (false).
## @param serviceAccount.annotations An empty dictionary to add any additional annotations you may want associated with the service account.
## @param serviceAccount.name The name for the serviceAccount to be created. If not defined, a name is generated using the `fullname` template.
serviceAccount:
  create: false
  annotations: {}
  name: ""

## @section Persistence parameters
## @descriptionStart
## In this section, you can specify where the application will persist data. For this application, all persistent data is stored on a volume.
## @descriptionEnd
## @extra persistence.[volume-name].size Indicates the size of the volume capacity for data persistent storage. It's string type. The format follows the pattern of the kubernetes resource model (integer number + units like Ki, Mi, Gi, Ti, Pi, Ei). In this example, the size is '8Gi' which denotes a volume of 8 Gibibytes.
## @extra persistence.[volume-name].mountPath A string that specifies the path within the container at which the volume should be mounted. In this snippet, '/data' is the directory path inside the container where the volume is mounted.

## @skip persistence
persistence: {}
#   volume-name:
#     size: 8Gi
#     mountPath: /data

migrationJob:
  enabled: true
  imagePullSecrets: []
  image:
    repository: ghcr.io/teableio/teable-db-migrate
    pullPolicy: IfNotPresent
    # Overrides the image tag whose default is the chart appVersion.
    tag: ""
  podAnnotations: {}
  podSecurityContext: {}
  securityContext: {}

  resources:
    limits:
      memory: 512Mi
    requests:
      cpu: 100m

  nodeSelector: {}
  tolerations: []
  affinity: {}
database:
  host: postgresql
  port: 5432
  name: synapse
  username: root
  password: ""
  extraArgs: {}

config:
  jwt:
    secret: null
  session:
    secret: null
  secretKey: null
  accessToken:
    encryption:
      key: null
      iv: null
  mail:
    host: null
    port: null
    secure: true
    sender: teable.localhost
    senderName: Teable
    auth:
      username: null
      password: null
  storage:
    provider: local
    publicBucket: 'public'
    privateBucket: 'private'
    minio:
      endPoint: null,
      port: null
      useSSL: null
      accessKey: null
      secretKey: null

